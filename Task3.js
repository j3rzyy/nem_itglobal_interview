// ЗАДАЧА
// Грабитель забегает с мешком на склад шариков разных цветов.
// Естественно, у него желание полностью наполнить свой мешок шариками и убежать.
// Но вместимость мешка ограничена, а у грабителя высоко развито чувство справедливости -
// он хочет забирать шарики пропорционально.
// Т.е. если на складе 20 синих шаров, 10 красных и 30 зеленых, а вместимость мешка =12,
// то грабитель заберет 4 синих, 2 красных и 6 зеленых.

// Задача написать программму, которая на входе принимает 2 параметра:
// - вместимость мешка; в примере выше это число 12.
// - массив с количеством, хранящихся на складе ресурсов; в примере выще это [20, 10, 30]
// На выходе возвращает массив той же размерности, что и на входе:
// - массив с количеством унесенных шаров; в примере выще это [4, 2, 6]

// Важно, заранее не известно сколько цветов шаров хранится на складе, поэтому на вход может прийти массив любой размерности,
// т.е. вместо [20, 10, 30] може прийти [7] или [5, 1, 3, 6, 77, 45, 345, 4] ...

// Вор руководствуется следующими правилами в порядке понижения важности:
// - жадность на первом месте - мешок важно наполнить максимально полно;
// - пропорция должна получаться максимально возможно справедливой.

// РЕШЕНИЕ
// Для простоты решения логически разделим задачу на два случая:
// 1. Идеальный - т.е. значения подобраны так, что пропорция дает целое число доступных для кражи шаров
// 2. Дробный - т.е. пропорция не гарантирует целого числа шаров
// *Также важно учесть случай, когда шаров на складе меньше, чем помещается в мешок.

// Алгоритм решения будет предполагать следующие шаги:
// 1. Найти отношение шаров каждого цвета к их общему количеству
// 2. На основе полученных значений отношения каждого цвета шара к их общему количеству, вычислить сколько шаров каждого цвета поместиться в мешке
// /* Решение идеального случая на этом завершается */
// 3. Определить сколько свободных мест осталось после применения решения для идеального случая
// 4. Теперь будем заполнять свободные места пока не исчерпаем свободные места в мешке или запас шаров на склад
// 5. Для этого создадим "карточку" каждого числа, со значением дробной части, в качестве id используется index каждого числа из исходного массива идеального случая
// 6. Отсортировав массив "карточек" по убыванию величины остатка (т.к. вор должен взять шар с большей дробной частью в первую очередь)
// 7. Далее будем прибавлять к количеству шаров каждого цвета по одному в зависимости от отстатка и убавлять свободные места.

// ОТВЕТ
function getStollenBalls(maxBallsNum, colorBalls) {
  const totalBallsNum = colorBalls.reduce((acc, elem) => acc + elem, 0); // ищем сколько всего шаров в хранилище
  const propsArr = colorBalls.map((el) => el / totalBallsNum); // находим пропорции через отношения шаров каждого цвета к общему их числу
  const stollenColorBalls = propsArr.map(
    (el) => Math.min(maxBallsNum, totalBallsNum) * el
  ); // используя ранее найденную пропорция определяем количество шаров, которые нужно украсть
  // для простых случаев (когда условие подобрано так, что количество шаров, которое нужно украсть, целое, а шаров на складе больше, чем места в мешке) этого достаточно
  // в ином случае
  const floorStollenColorBalls = stollenColorBalls.map((el) => Math.floor(el)); // округляем дробное число украденных шаров в меньшую сторону
  const countFloorStollenColorBalls = floorStollenColorBalls.reduce(
    (sum, el) => sum + el
  ); // счиатем сколько уже украли

  let emptySpace = maxBallsNum - countFloorStollenColorBalls; // определяем, есть ли незаполненные места для шаров в мешке

  if (emptySpace && countFloorStollenColorBalls < totalBallsNum) {
    // если свободных мест нет или в мешке больше места, чем всего шаров в хранилище, сразу возвращаем резульатат, иначе:
    const remainsIndex = stollenColorBalls
      .map((el, index) => ({
        remain: el - Math.floor(el),
        index,
      }))
      .sort((a, b) => b.remain - a.remain); // на основе массива с "честным" количеством шаров (с остатком для соблюдения истинной пропорции), создаем объект
    // в объекте будет храниться остаток и индекс числа, к которому он, отстаток, относится
    // сортируем массив объектов в порядке убывания значения остатка (remain), чтобы в первую очередь вор взял шар с большей дробной частью

    for (let i = 0; emptySpace > 0; i++) {
      floorStollenColorBalls[remainsIndex[i].index] += 1; // обращаемся к массиву объектов с остатками поочередно и на основе индекса прибавляем шар соответсвующего цвета
      emptySpace -= 1; // добавив шар, необходимо уменьшить количесвто свободных мест
    }
  }
  return floorStollenColorBalls; // возвращаем результат
}

console.log("12, [20, 10, 30], украдено: ", getStollenBalls(12, [20, 10, 30]));
console.log("8, [7, 4, 1], украдено: ", getStollenBalls(8, [7, 4, 1]));
console.log("7, [8], украдено: ", getStollenBalls(7, [8]));
console.log("20, [8, 2], украдено: ", getStollenBalls(20, [8, 2]));
